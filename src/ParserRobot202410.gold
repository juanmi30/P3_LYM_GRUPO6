using gold.**

toSet(C) :=  {x|  x in C}

///====   mini Parser===

function createParser(A):IPushdownAutomaton begin
	Q:=(-1‥4) ∪ {"defvar","assignment", "move", "skip", "turn", "face", "put", "pick", "move-dir", "run-dirs", "move-face"} ∪ {"if", "facing", "face", "north", "south", "east", "west",
	"blocked", "num", "canPut", "chips", "balloons", "canPick", "canMove",
	"isZero", "not", "loop", "repeat", "defun", "params", "funCall", "instruction",
	"endInst", "ifBlocks"}
	Σ:=toSet(A)  ∪ {' ', '\n'}
	
	Γ:={'1', '!', '?', '*', '%', '/','a', '+', 'b', 'i', '2'}
	q₀:=0
	F:= {0}
	M:=GPushdownAutomaton(Q,Σ,Γ,q₀,F)	
	SkipChars := {' ', '\n'}   // this will only  be used when testing only the parser as the lexer removes  SkipChars
	//transition for open and close  parenthesis astoplevel commands.You may use others for bllocks

 //(defvar name n)
 M.delta(0,"defvar","(vS#").ignore()
 M.delta(0,"defvar","(vSS").ignore()
 M.delta("defvar",0,")").ignore()

 //assignment (= name n)
 M.delta(0,"assignment","(=S#").ignore()
 M.delta(0,"assignment","(=SS").ignore()
 M.delta("assignment",0,")").ignore()

 //(move n)
 M.delta(0,"move","(m#").ignore()
 M.delta(0,"move","(mS").ignore()
 
 //En estructura
 M.delta(0,"move", "m#").push("b")
 M.delta(0, "move", "mS").push("b")
 M.delta(0, "move", "m#))").pop("i")
 M.delta(0, "move", "mS))").pop("i")
 M.delta("move", "endInst", λ).ignore()
 
 M.delta("move",0,")").ignore()
 
 //(skip n)
 M.delta(0,"skip","(s#").ignore()
 M.delta(0,"skip","(sS").ignore() 
 M.delta("skip",0,")").ignore()
 
 //(turn D)
 M.delta(0,"turn","(tX").ignore()
 M.delta(0,"turn","(tr").ignore()
 M.delta(0,"turn","(tA").ignore()
 M.delta("turn",0,")").ignore()
 
 //(face O)
 M.delta(0,"face","(fn").ignore()
 M.delta(0,"face","(fy").ignore()
 M.delta(0,"face","(fz").ignore()
 M.delta(0,"face","(fw").ignore()
 M.delta("face",0,")").ignore()
 
 //(put X n)
 M.delta(0,"put","(pb#").ignore()
 M.delta(0,"put","(pbS").ignore()
 M.delta(0,"put","(pc#").ignore()
 M.delta(0,"put","(pcS").ignore()
 M.delta("put",0,")").ignore()
 
 //(pick X n)
 M.delta(0,"pick","(kb#").ignore()
 M.delta(0,"pick","(kbS").ignore()
 M.delta(0,"pick","(kc#").ignore()
 M.delta(0,"pick","(kcS").ignore()
 M.delta("pick",0,")").ignore()
 
 //(move-dir n D)
 M.delta(0,"move-dir","(M#").ignore()
 M.delta(0,"move-dir","(MS").ignore()
 M.delta("move-dir",0,"d)").ignore()
 M.delta("move-dir",0,"r)").ignore()
 M.delta("move-dir",0,"X)").ignore()
 M.delta("move-dir",0,"q)").ignore()
 
 //(run-dirs Ds)
 M.delta(0,"run-dirs","(R").ignore()
 M.delta("run-dirs","run-dirs","d").ignore()
 M.delta("run-dirs","run-dirs","r").ignore()
 M.delta("run-dirs","run-dirs","X").ignore()
 M.delta("run-dirs","run-dirs","q").ignore()
 M.delta("run-dirs",0,")").ignore()
 
 //(move-face n O)
 M.delta(0,"move-face","(o#").ignore()
 M.delta(0,"move-face","(oS").ignore()
 M.delta("move-face",0,"n)").ignore()
 M.delta("move-face",0,"y)").ignore()
 M.delta("move-face",0,"z)").ignore()
 M.delta("move-face",0,"w)").ignore()
 
 //(null)
 M.delta(0,0,"(u)").ignore()
 
 //control estructures
 
 //if 
 M.delta(0, "if", "(i").push("?") 
 
 M.delta("if", "facing", "(C").ignore() //for facing
 
 M.delta("facing", "north", "n").ignore() // :north
 M.delta("north", "instruction", ')').changeTop("?", "2")
 M.delta("north", "instruction", ')').ignore()
 M.delta("north", "not", "))").pop("*") //in not
 
 M.delta("facing", "south", "y").ignore() //south
 M.delta("south", 0, ')').pop("!")
 M.delta("south", "not", "))").pop("!") //in not
 M.delta("facing", "east", "z").ignore() //east
 M.delta("east", 0, ')').pop("!")
 M.delta("east", "not", "))").pop("!") //in not
 M.delta("facing", "west", "w").ignore() //west
 M.delta("west", 0, ')').pop("!")
 M.delta("west", "not", "))").pop("!") //in not
 
 M.delta("if", "blocked", "(B").ignore() //for block
 M.delta("blocked", 0, ')').ignore()
 M.delta("blocked", "not", "))").ignore() //in not
 
 M.delta("if", "canPut", "(P").push("!") //for can-put
 M.delta("canPut", "chips", "c").ignore() //chips
 M.delta("chips", "num", '#').changeTop("!", "1")
 M.delta("canPut", "balloons", "b").ignore() //balloons
 M.delta("balloons", "num", '#').changeTop("!", "1")
 
 M.delta("if", "canPick", "(K").push("!") //for can-pick
 M.delta("canPick", "chips", "c").ignore() //chips
 M.delta("canPick", "balloons", "b").ignore() //balloons
 
 M.delta("if", "canMove", "(D").push("!") //for can-move
 M.delta("canMove", "north", "n").ignore() // :north
 M.delta("canMove", "south", "y").ignore() //south
 M.delta("canMove", "east", "z").ignore() //east
 M.delta("canMove", "west", "w").ignore() //west
 
 M.delta("if", "isZero", "(Z").push("!") //for isZero
 M.delta("isZero", "num", '#').changeTop("!", "1")
 
 M.delta("if", "if", "(N").push("*") // for not
 M.delta("not", "instruction", λ).changeTop("?", "2")
 M.delta("not", "instruction", λ).changeTop("%", "%")
 
 
 M.delta(0, "if", ')').changeTop("?", "1") // if end
 M.delta(0, "if", ')').pop("b")
 M.delta("if", "if", ')').changeTop("?", "1")
 M.delta("if", 0, "((").changeTop("2", "?")
 M.delta("if", 0, λ).pop("1")
 
 //loop
 M.delta(0, "loop", "(l").push("%") 
 M.delta("loop", "facing", "(C").ignore() //for facing
 M.delta("loop", "blocked", "(B").ignore() //for block
 M.delta("loop", "canPut", "(P").push("!") //for can-put
 M.delta("loop", "canPick", "(K").push("!") //for can-pick
 M.delta("loop", "canMove", "(D").push("!") //for can-move
 M.delta("loop", "isZero", "(Z").push("!") //for isZero
  
 M.delta("loop", "loop", "(N").push("*") //for not
 
 M.delta(0, "loop", ')').changeTop("%", "1") //loop end
 M.delta("endInst", "loop", λ).changeTop("%", "1")
 
 M.delta(0, "loop", ')').pop("b")
 M.delta("loop", "loop", ')').changeTop("%", "1")
 M.delta("loop", 0, λ).pop("1")
 
 //repeatTimes
 M.delta(0, "repeat", "(e").push("/")
 M.delta("repeat", "instruction", '#').ignore()
 M.delta("repeat", "instruction", 'S').ignore()
 
 M.delta(0, "repeat", ')').changeTop("/", "1")
 
 M.delta(0, "repeat", ')').pop("b")
 M.delta("repeat", "repeat", ')').changeTop("/", "1")
 M.delta("repeat", 0, λ).pop("1")
 M.delta("endInst", "repeat", λ).changeTop("/", "1")
    
 //Defun
 M.delta(0, "defun", "(FS").push("+")
 M.delta("defun", "params", '(').ignore()
 M.delta("params", "params", 'S').ignore()
 M.delta("params", 0, ')').ignore()
 M.delta(0, "defun", ')').changeTop("+", "1")
 M.delta("defun", 0, λ).pop("1")
 
 //procedure call
 M.delta(0, "funCall", "(S").ignore()
 M.delta("funCall", "funCall", 'S').ignore()
 M.delta("funCall", "funCall", '#').ignore()
 M.delta("funCall", 0, ')').ignore()
 
 M.delta("num", 0, ')').pop("1")
 M.delta("num", "not", "))").pop("1")
 
 //aux
 M.delta("instruction", 0, "((").ignore() //si hay bloque
 M.delta("instruction", 0, "(").push("i") //no hay bloque
 
 
 for each q in Q do
 	for each s in SkipChars do
 	   M.delta(q,q,λ+s).ignore()
 end
 end


return M
end

